[{"content":"","date":"2025年8月19日 ","externalUrl":null,"permalink":"/tags/fediverse/","section":"Tags","summary":"","title":"Fediverse","type":"tags"},{"content":"","date":"2025年8月19日 ","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"2025年8月19日 ","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"2025年8月19日 ","externalUrl":null,"permalink":"/","section":"Yaruki NotFound","summary":"","title":"Yaruki NotFound","type":"page"},{"content":"最近、英語の練習という名目でFEPの翻訳をしています。\nなぜやり始めたのか # FEPは英語で書かれています。機械翻訳することである程度読めるようにはなるものの、インラインコードが混じるとそれだけで文章の順序が変になって結局は読みにくくなってしまいます。それくらいならFEPを直接翻訳して日本語で読めるようにすればいい、そう思って書き始めました。\n方法 # 主にLLM (Gemini)と手動を組み合わせています\nただLLMが優秀なので今のところは手動で手を加えたりはしてないです\n昔は機械翻訳 + 手動修正でした (スクリプトを組んでなかったので死ぬほど手間がかかりました)\n翻訳されるFEPに関しては、どのFEPが比較的参照されるかなどを勝手に考えてそのFEPのIDをconfigに書き込んで、1日に何個みたいに手作業でスクリプトを動かしてLLMに通してます (というよりは自分が使うFEPから先に翻訳しています)\n他の言語 # 一応、別の言語の翻訳版も作れるはずです。試していないのでわかりませんが。\n","date":"2025年8月19日 ","externalUrl":null,"permalink":"/posts/1755638884469-%E5%8B%9D%E6%89%8B%E3%81%ABfep%E3%81%AE%E6%97%A5%E6%9C%AC%E8%AA%9E%E8%A8%B3%E3%82%92%E3%81%97%E3%81%A6%E3%81%84%E3%82%8B%E8%A9%B1/","section":"Posts","summary":"","title":"勝手にFEPの日本語訳をしている話","type":"posts"},{"content":"","date":"2025年8月18日 ","externalUrl":null,"permalink":"/tags/example/","section":"Tags","summary":"","title":"Example","type":"tags"},{"content":" これはHacker\u0026rsquo;s Pubからの本人による無断転載です FreeBSDで起動できるように修正されたMisskeyおよびSharkey（変更がすでに適用済み）をFedora 42環境にインストールする際、以下のエラーが発生することがあります。\nerror: ‘uint8_t’ was not declared in this scope error: ‘state’ was not declared in this scope これらの問題は、使用しているGCCのバージョンに起因しているようです（参照）。以下に、Fedora 42でこれらの問題を解決する方法を示します。\nステップ1: 依存関係のインストール # まず、Wikiに記載されているように、必要な依存関係をインストールします。\nsudo dnf install cairo-devel libjpeg-turbo-devel pango-devel giflib-devel pixman-devel ステップ2: GCC/G++のコンパイル # FedoraにバンドルされているデフォルトのGCCを使用すると、pnpm installを実行した際にインストールが失敗する可能性があります（2025年5月27日現在）。この問題を避けるために、別のGCC/G++のバージョンをコンパイルして使用する必要があります。\nまず、wgetを使用してGCCのソースコードをダウンロードし、解凍した後、ソースディレクトリに移動します。\nwget https://ftp.tsukuba.wide.ad.jp/software/gcc/releases/gcc-13.3.0/gcc-13.3.0.tar.gz tar xzf gcc-13.3.0.tar.gz cd gcc-13.3.0 mkdir build cd build 次に、GCC/G++をビルドするために必要な依存関係をインストールします。\nsudo dnf group install development-tools sudo dnf install mpfr-devel gmp-devel libmpc-devel zlib-devel glibc-devel.i686 glibc-devel isl-devel libgphobos-static 次に、ビルドを設定します（フラグは必要に応じて変更してください）。\n../configure --disable-bootstrap --prefix=/usr --program-suffix=-13.3 --mandir=/usr/share/man --enable-languages=c,c++ 設定が完了したら、以下のコマンドでGCCをコンパイルします。\nmake より速いビルドのために複数のコアを利用するには、-jフラグを使用します。\nmake -j6 コンパイルが完了したら、新しいGCCバージョンをインストールします。\nsudo make install コンパイルしたGCCのインストールを確認するには、以下のコマンドを使用します。\ngcc-13.3 -v ステップ3: Misskey/Sharkeyのインストールコマンドを修正 # 最後に、SharkeyとMisskeyを正常にインストールするために、インストールコマンドを以下のように修正します。\nCXX=/usr/sbin/g++-13.3 CC=/usr/sbin/gcc-13.3 pnpm install --frozen-lockfile これらの調整を行うことで、MisskeyとSharkeyを問題なくインストールできるはずです。Fediverseを楽しんでください！\n*テキストを自然にするためにLLMをある程度使用しました。投稿前に確認しましたが、不自然な部分があればお知らせください。\n参考文献 # Fedora 41/40でGCC 14を使用してGCC 13.3をビルドする方法 ","date":"2025年8月18日 ","externalUrl":null,"permalink":"/posts/1755531106734-sharkey/misskeyfreebsd%E7%94%A8%E3%81%AE%E4%BF%AE%E6%AD%A3%E3%82%92%E5%90%AB%E3%82%80%E3%82%92fedora-42%E3%81%AB%E3%82%A4%E3%83%B3%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AB%E3%81%99%E3%82%8B%E6%96%B9%E6%B3%95/","section":"Posts","summary":"","title":"SharkeyやMisskeyをFedora 42にインストールするときに発生する問題に対処する","type":"posts"},{"content":"","date":"2025年8月18日 ","externalUrl":null,"permalink":"/tags/tag/","section":"Tags","summary":"","title":"Tag","type":"tags"},{"content":" この記事はMisskey Advent Calendar 2024 21日目の記事です\n← 20日目の記事 | 22日目の記事 →\nMedia Proxy for Misskeyやsummalyをいろんな言語で再実装してみてる話です。駄文ですが許してください\nもともとはAPIラッパーの話をしようと思ってたんですが、色々問題が起こりすぎて間に合いそうになかったので変えました\n何で作ったのか # 特に理由はなかったりします ただ作ってみたかったからっていうのが理由です (ちなみにsummaly-pyは初期はsummergoを無理矢理Pythonで動かすだけのお遊び的な実装でした)\nちなみにsummalyとMedia Proxyだとsummalyの方が実装が面倒でした\nmedia-proxy-goはGoの勉強のために作ってみました (微妙なので使うのはおすすめしません)\n発生した問題など # summaly-py # 最初から殆ど問題はなかったかもしれません 強いて言えばcontent_length_limitがNone (null)な場合にエラーが返ってくるくらいです\nmedia-proxy # media-proxyは初期に使ってたライブラリのPillowだと大きな画像を処理できずにエラーを返してくる問題がありました。 (#1)\n結局本家で使われているSharpと同じlibvipsを使うpyvipsを使うようにしたら解決して少し早くなったような気がします。\nGIFがおかしくなる問題は結局GIFはそのまま返すようにして無理矢理解決しました。\nmedia-proxy-go # 多すぎて覚えてない 横長の画像をリサイズすると押し潰される\n作ってみた感想 # summaly-pyは使ったことのないXPathを書いていて少しだけ大変だった media-proxyは最初は大きいメディアを処理できなかったり問題が多かった (改善済み) GIFは未だにバグるので処理できない media-proxy-goはWindowsでは使えない ゴミみたいな感想ですね\n最後に # 記事を書いてたら足の力がだんだん入らなくなってきました。助けてください\n記事を書くのって大変ですね\nRepos # media-proxy # AmaseCocoa/media-proxy Pythonで作成されたMedia Proxyの代替実装 Python 0 0 media-proxy-go # AmaseCocoa/media-proxy-go Media Proxy for Misskey Go 0 0 summaly-py # AmaseCocoa/summaly-py misskey-dev/summalyのPython実装。 Python 0 0 ","date":"2024年12月21日 ","externalUrl":null,"permalink":"/posts/misskey-calendar-2024/","section":"Posts","summary":"","title":"Misskeyのいろいろなものを別の言語で再実装してみてる話","type":"posts"},{"content":"","date":"2024年12月21日 ","externalUrl":null,"permalink":"/tags/tech/","section":"Tags","summary":"","title":"Tech","type":"tags"},{"content":"自作CMSをやめてDecap CMSを使ってみた。\n他の案 # Wordpress (ヘッドレス) # へッドレスCMSとしてWordpressを使う案。実際、実装は完成していた。でも微妙だったのでやめた。\nmicroCMS # 日本製のヘッドレスCMS。転送量の制限が気になるので結局やめた。\nDecap CMS # 旧Netlify CMS。Gitを使える。Netlifyとの連携が強い (Cloudflare Pagesとかでも動かせなくはない)。Gitを使える (ここ大事)\nなんで選んだの # データベースが不要 (Wordpressを使う場合はこれが課題だった) 無料 (お金がないんです😇) それ以外に使った技術 # Pagefind (検索用。ホームとかにある検索ボックスがそれ) Hugo (ビルド時間が短くなりそうっていう勝手な妄想から。あとは使ったことがあるから) UI # TailwindCSS PhotoSwipe Barba.js v2 + GSAP (非同期転移。読み込みのときに一度真っ白になるのが気になるので…) テーマは自作しました。\n構築してみる # 以下のコマンドを実行してhugoのサイトを作成する。テーマはhugo-theme-stackを使う。\nhugo new site decap-site cd decap-site/themes git clone https://github.com/CaiJimmy/hugo-theme-stack.git cd .. 完了したらhugo.tomlを開いて以下の項目を追加する。\ntheme = \u0026#39;hugo-theme-stack\u0026#39; 次にhugo serveを実行して正常に起動したら完了。\nDecap CMSを導入する # 導入は意外と簡単にできた。 まずはstaticディレクトリに移動する。\ncd static 次にstaticディレクトリにadminディレクトリを作成してadminディレクトリに移動。\nmkdir admin cd admin config.ymlを作成して以下をペーストする。\n※このブログで使っているものです\nlocale: \u0026#34;ja\u0026#34; local_backend: true backend: name: git-gateway branch: main collections: - name: \u0026#34;post\u0026#34; label: \u0026#34;Post\u0026#34; folder: \u0026#34;content/posts\u0026#34; create: true slug: \u0026#34;{{fields.filename}}\u0026#34; preview_path: \u0026#34;posts/{{slug}}\u0026#34; type: \u0026#34;post\u0026#34; fields: - { label: \u0026#34;Title\u0026#34;, name: \u0026#34;title\u0026#34;, widget: \u0026#34;string\u0026#34; } - {label: \u0026#34;Type\u0026#34;, name: \u0026#34;type\u0026#34;, widget: \u0026#34;hidden\u0026#34;, default: \u0026#34;post\u0026#34;, hint: \u0026#34;ファイルの種類 (通常は変更する必要はありません)\u0026#34;} - { label: \u0026#34;File Name\u0026#34;, name: \u0026#34;filename\u0026#34;, widget: \u0026#34;datetime\u0026#34;, date_format: \u0026#34;YYYY-MM-DD\u0026#34;, time_format: false, format: \u0026#34;YYYY-MM-DD\u0026#34;, hint: \u0026#34;作成されるファイル名と記事のURLで使用されます。新規作成時のみ有効な設定です。\u0026#34;, } - { label: \u0026#34;Publish Date\u0026#34;, name: \u0026#34;date\u0026#34;, widget: \u0026#34;datetime\u0026#34;, date_format: \u0026#34;YYYY-MM-DD\u0026#34;, time_format: \u0026#34;HH:mm:ss+09:00\u0026#34;, format: \u0026#34;YYYY-MM-DDTHH:mm:ss+09:00\u0026#34;, hint: \u0026#34;公開日の設定です。未来の時刻では公開されません。\u0026#34;, } - { label: \u0026#34;Draft\u0026#34;, name: \u0026#34;draft\u0026#34;, widget: \u0026#34;boolean\u0026#34;, default: true, hint: \u0026#34;下書きとして保存するかどうかを設定します。\u0026#34;, } - { label: \u0026#34;Tags\u0026#34;, name: \u0026#34;tags\u0026#34;, widget: \u0026#34;list\u0026#34;, hint: \u0026#34;タグはカンマ区切りで指定します。\u0026#34;, } - {label: \u0026#34;Category\u0026#34;, name: \u0026#34;category\u0026#34;, widget: \u0026#34;list\u0026#34;, hint: \u0026#34;カテゴリーはカンマ区切りで指定します。\u0026#34;,} - {label: \u0026#34;Author\u0026#34;, name: \u0026#34;author\u0026#34;, widget: \u0026#34;relation\u0026#34;, collection: \u0026#34;authors\u0026#34;, searchFields: [\u0026#34;name\u0026#34;], valueField: \u0026#34;name\u0026#34;} - { label: \u0026#34;Body\u0026#34;, name: \u0026#34;body\u0026#34;, widget: \u0026#34;markdown\u0026#34; } - name: \u0026#34;authors\u0026#34; label: \u0026#34;Authors\u0026#34; folder: \u0026#34;content/authors\u0026#34; create: true slug: \u0026#34;{{fields.slug}}\u0026#34; fields: - {label: \u0026#34;Slug\u0026#34;, name: \u0026#34;slug\u0026#34;, widget: \u0026#34;string\u0026#34;, hint: \u0026#34;英字である必要があります。\u0026#34;} - {label: \u0026#34;Name\u0026#34;, name: \u0026#34;name\u0026#34;, widget: \u0026#34;string\u0026#34;} - {label: \u0026#34;Bio\u0026#34;, name: \u0026#34;bio\u0026#34;, widget: \u0026#34;text\u0026#34;} - {label: \u0026#34;Avatar\u0026#34;, name: \u0026#34;avatar\u0026#34;, widget: \u0026#34;string\u0026#34;} - label: \u0026#34;Links\u0026#34; name: \u0026#34;links\u0026#34; widget: \u0026#34;list\u0026#34; fields: - {label: \u0026#34;URL\u0026#34;, name: \u0026#34;url\u0026#34;, widget: \u0026#34;string\u0026#34;} - {label: \u0026#34;Icon\u0026#34;, name: \u0026#34;icon\u0026#34;, widget: \u0026#34;string\u0026#34;} - {label: \u0026#34;Content\u0026#34;, name: \u0026#34;body\u0026#34;, widget: \u0026#34;markdown\u0026#34;} media_folder: \u0026#34;static/uploads\u0026#34; public_folder: \u0026#34;/uploads\u0026#34; 次にindex.htmlを作成して以下のコードをペーストする\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;robots\u0026#34; content=\u0026#34;noindex\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Content Manager\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;https://identity.netlify.com/v1/netlify-identity-widget.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script src=\u0026#34;https://unpkg.com/decap-cms@^3.0.0/dist/decap-cms.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; hugo serveでサーバーを起動したらサーバーのアドレス/adminにアクセスして画像の画面が表示されるか確認する。表示されたらNetlifyの設定をする。\nログイン画面 Netlifyの設定 # ここからはこのブログの管理画面を使います (?)\nNetlifyのプロジェクトの作成に関しては割愛します。\n※Builds are stoppedと表示されているのはこのウェブサイトはPagefindを使う都合で別の場所でビルドしているからです。 サイドバーの「Integrations」をクリックし、出てきたページの「Identity」をクリックします。すると、右に「Netlify Identity」というのがあるのでそれの下にある「Enable」をクリックしてIdentityを有効化します。\n次に「Site configuration」に戻って、下にスクロールしたところにあるIdentityをクリックします。すると画像のような画面が表示されるので、「Registration preferences」を「Open」から「Invite only」に変更します。\n次にintegrationsからidentityの部分に戻ります。Netlify Identityの下にあるviewをクリックして転移した画面で表示される、「Invite users」をクリックします。表示されたモーダルに自分のメールアドレスを入力したあと、sendをクリックします。\nすると画像のようなメールが送信されているはずなので、それのリンクをコピーします。\n※このままクリックしても管理画面ではない場合は登録されないため\n`#を除いたリンク/admin/#以降の文字列`のように置き換えてアクセスしてください。\nするとおそらく管理画面が表示されます。\n次にNetlifyのGit-Gatewayを有効化します。\nまず、Site configurationのIdentityに戻ります。下の方にスクロールして「Git Gateway」の項目を見つけたら、「Enable Git Gateway」をクリックしてGit Gatewayを有効化します。これで導入は終わりです。\n感想 # 簡単にできた。\n今度Netlify以外での方法も書くかもしれません。\nあとがき # これ投稿してからPhotoSwipeのCSSを同梱してないことに気づいた。\n","date":"2024年9月13日 ","externalUrl":null,"permalink":"/posts/try-decap/","section":"Posts","summary":"","title":"Decap CMSを使ってみる","type":"posts"},{"content":"","date":"2024年9月13日 ","externalUrl":null,"permalink":"/tags/decap-cms/","section":"Tags","summary":"","title":"Decap-Cms","type":"tags"},{"content":"","date":"2024年9月13日 ","externalUrl":null,"permalink":"/tags/git/","section":"Tags","summary":"","title":"Git","type":"tags"},{"content":"","date":"2024年9月13日 ","externalUrl":null,"permalink":"/tags/hugo/","section":"Tags","summary":"","title":"Hugo","type":"tags"},{"content":"","date":"2024年8月29日 ","externalUrl":null,"permalink":"/tags/meilisearch/","section":"Tags","summary":"","title":"Meilisearch","type":"tags"},{"content":"","date":"2024年8月29日 ","externalUrl":null,"permalink":"/tags/misskey/","section":"Tags","summary":"","title":"Misskey","type":"tags"},{"content":"体感ではそんな印象はないけど気になるので入れ替えてみる。\nDocker # アップデート手順はほとんど参考記事のものです。\nコンテナを停止する。\n1 $ docker compose down dumpを作成する。\n$ curl -X POST \u0026#39;http://meilisearchのFQDN/dumps\u0026#39; -H \u0026#39;Authorization: Bearer (MEILI_MASTER_KEYに設定した値)\u0026#39; 以下を実行してstatusがsucceededになったらok。\n$ curl -X POST \u0026#39;http://meilisearchのFQDN/tasks/(dumpsの返り値のtaskUid)\u0026#39; -H \u0026#39;Authorization: Bearer (MEILI_MASTER_KEYに設定した値)\u0026#39; (composeに設定したmeilisearchのディレクトリ)/dumpsにdumpファイルが生成されているはず。\n(念の為) 先に(composeに設定したmeilisearchのディレクトリ)/data.msを別の場所にコピーしておく。\nMeilisearchのdocker imageをMeilisearch 1.3.0系の\nimage: getmeili/meilisearch:prototype-japanese-4 に置き換える。\n次にこのコマンドを実行してdumpを取り込む\n$ docker run -it --rm -p 7700:7700 -v /meili_data:/meili_data getmeili/meilisearch:prototype-japanese-4 meilisearch --import-dump /meili_data/dumps/(dumpの名前) 最後にコンテナを起動して完了。\n$ docker compose up -d 参考 # Meilisearchのバージョンアップ手順(Docker版) https://github.com/meilisearch/meilisearch/pull/3882 非Docker # 自動でビルドされたバイナリをリリースに投げるようにしました。ビルドが面倒だったりリソースが不足したりする人はここからダウンロードすることもできます。 AmaseCocoa/Meilisearch-JPNBuild 日本語の精度を向上させるために中国語のトークン化を無効にしたMeilisearchビルド。 null 1 0 ビルドする場合 # Dockerを使っていない場合は少し手順が複雑になる。\nGitとRustがインストールされていない場合はインストールする。\nMeilisearchのリポジトリをクローン、ディレクトリを移動する。\n$ git clone https://github.com/meilisearch/meilisearch $ cd meilisearch v1.3.4をチェックアウトする\n$ git checkout v1.3.4 最後にrustをアップデートして、中国語のトークン化を無効にしたバージョンのMeilisearchをビルドする。\n$ rustup update $ cargo build --release -p meilisearch -p meilitool --no-default-features --features \u0026#34;analytics mini-dashboard japanese\u0026#34; 最後にドキュメントの手順を実行してMeilisearchを更新すれば完了。\n参考 # https://github.com/meilisearch/meilisearch/issues/4561#issuecomment-2058594295 https://github.com/meilisearch/meilisearch/pull/3882 注意点 # 中国語のトークン化を無効にして精度を向上させているらしいので(このあたりは詳しくないのでわかりませんが) 多分中国語の精度がめちゃくちゃ落ちます。\n","date":"2024年8月29日 ","externalUrl":null,"permalink":"/posts/meilisearch-japanese-build/","section":"Posts","summary":"","title":"MisskeyでMeilisearchを利用する際の日本語検索の精度を向上させる","type":"posts"},{"content":"Media-Proxyを作成したのでそのコードについて説明したりするだけ。\n※これは古いバージョンのコードです。Pillowを使っているので大きな画像は処理できません\nimport os import logging import traceback import aiofiles import aiohttp import aiohttp.web as web from aiohttp_cache import ( setup_cache, cache, ) from PIL import Image import io import urllib.parse logger = logging.getLogger(__name__) async def fetch_image(session: aiohttp.ClientSession, url): async with session.get(url) as response: if not response.ok: return None else: content_type = response.headers.get(\u0026#34;Content-Type\u0026#34;, \u0026#34;\u0026#34;).lower() data = bytearray() while True: chunk = await response.content.read(int(os.environ.get(\u0026#34;CHUNK_SIZE\u0026#34;, 1048576))) if not chunk: break data.extend(chunk) return data, content_type @cache(expires=os.environ.get(\u0026#34;EXPIRES\u0026#34;, 86400) * 1000) async def proxy_image(request): query_params = request.rel_url.query url = query_params.get(\u0026#34;url\u0026#34;) fallback = \u0026#34;fallback\u0026#34; in query_params emoji = \u0026#34;emoji\u0026#34; in query_params avatar = \u0026#34;avatar\u0026#34; in query_params static = \u0026#34;static\u0026#34; in query_params preview = \u0026#34;preview\u0026#34; in query_params badge = \u0026#34;badge\u0026#34; in query_params try: if not url: return web.Response(status=400, text=\u0026#34;Missing \u0026#39;url\u0026#39; parameter\u0026#34;) try: url = urllib.parse.unquote(url) except Exception as e: return web.Response(status=400, text=\u0026#34;Invalid \u0026#39;url\u0026#39; parameter\u0026#34;) async with aiohttp.ClientSession() as session: image_data, content_type = await fetch_image(session, url) if image_data is None: if fallback: headers = { \u0026#34;Cache-Control\u0026#34;: \u0026#34;max-age=300\u0026#34;, \u0026#34;Content-Type\u0026#34;: \u0026#34;image/webp\u0026#34;, \u0026#34;Content-Security-Policy\u0026#34;: \u0026#34;default-src \u0026#39;none\u0026#39;; img-src \u0026#39;self\u0026#39;; media-src \u0026#39;self\u0026#39;; style-src \u0026#39;unsafe-inline\u0026#39;\u0026#34;, \u0026#34;Content-Disposition\u0026#34;: \u0026#34;inline; filename=image.webp\u0026#34;, } async with aiofiles.open(\u0026#34;./assets/fallback.webp\u0026#34;, \u0026#34;rb\u0026#34;) as f: return web.Response( status=200, body=await f.read(), headers=headers ) return web.Response(status=404, text=\u0026#34;Image not found\u0026#34;) if \u0026#34;image\u0026#34; not in content_type: logger.info(\u0026#34;Media is Not Image. Redirecting to Response...\u0026#34;) headers = { \u0026#34;Cache-Control\u0026#34;: \u0026#34;max-age=31536000, immutable\u0026#34;, \u0026#34;Content-Type\u0026#34;: content_type, \u0026#34;Content-Security-Policy\u0026#34;: \u0026#34;default-src \u0026#39;none\u0026#39;; img-src \u0026#39;self\u0026#39;; media-src \u0026#39;self\u0026#39;; style-src \u0026#39;unsafe-inline\u0026#39;\u0026#34;, \u0026#34;Content-Disposition\u0026#34;: \u0026#34;inline; filename=image.webp\u0026#34;, } return web.Response(status=200, body=image_data, headers=headers) image = Image.open(io.BytesIO(image_data)) if emoji: image.thumbnail((128, 128)) elif avatar: image.thumbnail((320, 320)) elif preview: image.thumbnail((200, 200)) elif badge: image = image.convert(\u0026#34;RGBA\u0026#34;) image = image.resize((96, 96)) output = io.BytesIO() image_format = \u0026#34;WEBP\u0026#34; if not badge else \u0026#34;PNG\u0026#34; if image_format == \u0026#34;PNG\u0026#34;: image.save(output, format=image_format, optimize=True) elif image_format == \u0026#34;WEBP\u0026#34;: image.save(output, format=image_format, quality=80) output.seek(0) headers = { \u0026#34;Cache-Control\u0026#34;: \u0026#34;max-age=31536000, immutable\u0026#34; if image_data else \u0026#34;max-age=300\u0026#34;, \u0026#34;Content-Type\u0026#34;: f\u0026#34;image/{image_format.lower()}\u0026#34;, \u0026#34;Content-Security-Policy\u0026#34;: \u0026#34;default-src \u0026#39;none\u0026#39;; img-src \u0026#39;self\u0026#39;; media-src \u0026#39;self\u0026#39;; style-src \u0026#39;unsafe-inline\u0026#39;\u0026#34;, \u0026#34;Content-Disposition\u0026#34;: f\u0026#34;inline; filename=image.{image_format.lower()}\u0026#34;, } return web.Response(body=output.read(), headers=headers) except Exception as e: print(traceback.format_exc()) if fallback: headers = { \u0026#34;Cache-Control\u0026#34;: \u0026#34;max-age=300\u0026#34;, \u0026#34;Content-Type\u0026#34;: \u0026#34;image/webp\u0026#34;, \u0026#34;Content-Security-Policy\u0026#34;: \u0026#34;default-src \u0026#39;none\u0026#39;; img-src \u0026#39;self\u0026#39;; media-src \u0026#39;self\u0026#39;; style-src \u0026#39;unsafe-inline\u0026#39;\u0026#34;, \u0026#34;Content-Disposition\u0026#34;: \u0026#34;inline; filename=image.webp\u0026#34;, } async with aiofiles.open(\u0026#34;./assets/fallback.webp\u0026#34;, \u0026#34;rb\u0026#34;) as f: return web.Response( status=200, body=await f.read(), headers=headers ) return web.Response(status=404, text=\u0026#34;Image not found\u0026#34;) app = web.Application() setup_cache(app) app.router.add_get(\u0026#34;/proxy/{filename}\u0026#34;, proxy_image) app.router.add_get(\u0026#34;/\u0026#34;, proxy_image) app.router.add_get(\u0026#34;/{filename}\u0026#34;, proxy_image) if __name__ == \u0026#34;__main__\u0026#34;: web.run_app( app, port=os.environ.get(\u0026#34;PORT\u0026#34;, 3003), host=os.environ.get(\u0026#34;HOST\u0026#34;, \u0026#34;0.0.0.0\u0026#34;) ) モジュールの読み込み # import os import logging import traceback import aiofiles import aiohttp import aiohttp.web as web from aiohttp_cache import ( setup_cache, cache, ) from PIL import Image import io import urllib.parse aiohttpとaiohttp.web：HTTPクライアントとサーバー。 aiofiles：個人的にwith openだと気になるので。使う必要はあまりないかも。 PIL（Pillow）：画像処理ライブラリ。圧縮などに利用します urllib.parse：URLのパースとエンコード/デコード用 aiohttp_cache：キャッシュ 2. ログの設定 # logger = logging.getLogger(__name__) 3. 画像の取得 # async def fetch_image(session: aiohttp.ClientSession, url): async with session.get(url) as response: if not response.ok: return None else: content_type = response.headers.get(\u0026#34;Content-Type\u0026#34;, \u0026#34;\u0026#34;).lower() data = bytearray() while True: chunk = await response.content.read(int(os.environ.get(\u0026#34;CHUNK_SIZE\u0026#34;, 1048576))) if not chunk: break data.extend(chunk) return data, content_type 指定されたURLから画像を非同期で取得し、バイトデータとコンテンツタイプを返す。一気に取得するのではなく (一気に取得してしまうと大きなファイルでは遅くなるので)1MBづつチャンクで取得するようになっています。\n4. ルート部分 # @cache(expires=os.environ.get(\u0026#34;EXPIRES\u0026#34;, 86400) * 1000) async def proxy_image(request): query_params = request.rel_url.query url = query_params.get(\u0026#34;url\u0026#34;) fallback = \u0026#34;fallback\u0026#34; in query_params emoji = \u0026#34;emoji\u0026#34; in query_params avatar = \u0026#34;avatar\u0026#34; in query_params static = \u0026#34;static\u0026#34; in query_params preview = \u0026#34;preview\u0026#34; in query_params badge = \u0026#34;badge\u0026#34; in query_params try: if not url: return web.Response(status=400, text=\u0026#34;Missing \u0026#39;url\u0026#39; parameter\u0026#34;) try: url = urllib.parse.unquote(url) except Exception as e: return web.Response(status=400, text=\u0026#34;Invalid \u0026#39;url\u0026#39; parameter\u0026#34;) async with aiohttp.ClientSession() as session: image_data, content_type = await fetch_image(session, url) if image_data is None: if fallback: headers = { \u0026#34;Cache-Control\u0026#34;: \u0026#34;max-age=300\u0026#34;, \u0026#34;Content-Type\u0026#34;: \u0026#34;image/webp\u0026#34;, \u0026#34;Content-Security-Policy\u0026#34;: \u0026#34;default-src \u0026#39;none\u0026#39;; img-src \u0026#39;self\u0026#39;; media-src \u0026#39;self\u0026#39;; style-src \u0026#39;unsafe-inline\u0026#39;\u0026#34;, \u0026#34;Content-Disposition\u0026#34;: \u0026#34;inline; filename=image.webp\u0026#34;, } async with aiofiles.open(\u0026#34;./assets/fallback.webp\u0026#34;, \u0026#34;rb\u0026#34;) as f: return web.Response( status=200, body=await f.read(), headers=headers ) return web.Response(status=404, text=\u0026#34;Image not found\u0026#34;) if \u0026#34;image\u0026#34; not in content_type: logger.info(\u0026#34;Media is Not Image. Redirecting to Response...\u0026#34;) headers = { \u0026#34;Cache-Control\u0026#34;: \u0026#34;max-age=31536000, immutable\u0026#34;, \u0026#34;Content-Type\u0026#34;: content_type, \u0026#34;Content-Security-Policy\u0026#34;: \u0026#34;default-src \u0026#39;none\u0026#39;; img-src \u0026#39;self\u0026#39;; media-src \u0026#39;self\u0026#39;; style-src \u0026#39;unsafe-inline\u0026#39;\u0026#34;, \u0026#34;Content-Disposition\u0026#34;: \u0026#34;inline; filename=image.webp\u0026#34;, } return web.Response(status=200, body=image_data, headers=headers) image = Image.open(io.BytesIO(image_data)) if emoji: image.thumbnail((128, 128)) elif avatar: image.thumbnail((320, 320)) elif preview: image.thumbnail((200, 200)) elif badge: image = image.convert(\u0026#34;RGBA\u0026#34;) image = image.resize((96, 96)) output = io.BytesIO() image_format = \u0026#34;WEBP\u0026#34; if not badge else \u0026#34;PNG\u0026#34; if image_format == \u0026#34;PNG\u0026#34;: image.save(output, format=image_format, optimize=True) elif image_format == \u0026#34;WEBP\u0026#34;: image.save(output, format=image_format, quality=80) output.seek(0) headers = { \u0026#34;Cache-Control\u0026#34;: \u0026#34;max-age=31536000, immutable\u0026#34; if image_data else \u0026#34;max-age=300\u0026#34;, \u0026#34;Content-Type\u0026#34;: f\u0026#34;image/{image_format.lower()}\u0026#34;, \u0026#34;Content-Security-Policy\u0026#34;: \u0026#34;default-src \u0026#39;none\u0026#39;; img-src \u0026#39;self\u0026#39;; media-src \u0026#39;self\u0026#39;; style-src \u0026#39;unsafe-inline\u0026#39;\u0026#34;, \u0026#34;Content-Disposition\u0026#34;: f\u0026#34;inline; filename=image.{image_format.lower()}\u0026#34;, } return web.Response(body=output.read(), headers=headers) except Exception as e: print(traceback.format_exc()) if fallback: headers = { \u0026#34;Cache-Control\u0026#34;: \u0026#34;max-age=300\u0026#34;, \u0026#34;Content-Type\u0026#34;: \u0026#34;image/webp\u0026#34;, \u0026#34;Content-Security-Policy\u0026#34;: \u0026#34;default-src \u0026#39;none\u0026#39;; img-src \u0026#39;self\u0026#39;; media-src \u0026#39;self\u0026#39;; style-src \u0026#39;unsafe-inline\u0026#39;\u0026#34;, \u0026#34;Content-Disposition\u0026#34;: \u0026#34;inline; filename=image.webp\u0026#34;, } async with aiofiles.open(\u0026#34;./assets/fallback.webp\u0026#34;, \u0026#34;rb\u0026#34;) as f: return web.Response( status=200, body=await f.read(), headers=headers ) return web.Response(status=404, text=\u0026#34;Image not found\u0026#34;) クエリパラメータを取得し、画像のURLを取得。\n画像が見つからない場合やエラーが発生した場合の処理。\n画像の種類に応じてサムネイルなどの処理を行い、適切なヘッダーを設定してレスポンスを返す。\n5. サーバーの設定 # app = web.Application() setup_cache(app) app.router.add_get(\u0026#34;/proxy/{filename}\u0026#34;, proxy_image) app.router.add_get(\u0026#34;/\u0026#34;, proxy_image) app.router.add_get(\u0026#34;/{filename}\u0026#34;, proxy_image) if __name__ == \u0026#34;__main__\u0026#34;: web.run_app( app, port=os.environ.get(\u0026#34;PORT\u0026#34;, 3003), host=os.environ.get(\u0026#34;HOST\u0026#34;, \u0026#34;0.0.0.0\u0026#34;) ) aiohttpを使ってWebアプリケーションを設定。\nキャッシュの設定。\n/proxy/{filename}、/、/{filename}のルートにproxy_imageハンドラを設定。\nアプリケーションを指定されたホストとポートで実行。ここは環境変数で変更できます。\nちなみに本当はintに変換しないといけないのにこのときのぼくは忘れていました\n","date":"2024年8月28日 ","externalUrl":null,"permalink":"/posts/diy-media-proxy/","section":"Posts","summary":"","title":"MisskeyのMedia Proxyを自作した","type":"posts"},{"content":"","date":"2024年8月28日 ","externalUrl":null,"permalink":"/tags/python/","section":"Tags","summary":"","title":"Python","type":"tags"},{"content":"何故かCMSからブログを作ってしまいました。\nちなみに今はDecap CMS + Fuwari (Astro)の構成に移行しているので自作CMSは使ってません 結局Blowfishになった どうして？ # なんとなく興味があったから。 管理画面とされているページ\n使ってる技術 # バックエンド # FastAPI uvicorn Python-Markdown (を少し拡張してます) PostgreSQL (CockroachDB) ちなみにスキーマいじればどのDBでも使えると思います Prisma側の検索機能も対応したいならPostgresかMySQLしか駄目かも Prisma フロントエンド # Bootstrap EasyMDE (WYSIWYGエディター) サービス # Render (PaaS) CockroachDB Cloud amsc.pages.devから変わった点 # 静的サイトではなくなった サーバー側でレンダリングしたページを返す形式になった Twemojiが使えるようになった ただし絵文字を直接変換することはできなくて絵文字のコード (\u0026#x1f44d;なら:thumbsup:)を打つ必要がある 将来的には絵文字を直接変換できるようにするか絵文字ピッカーを実装したい 動的にcssやjsを圧縮できるようになった 管理画面ができた 投稿が簡単に編集できるようになった 削除も同じく 閲覧数がカウントされるようになった 精度が低いので見れないようになってるけど一応カウントされてます 検索機能が実装された ← NEW!!! やりたいこと # 画像自体をエディターから上げられるようにしたい 現状はできない 実現するならS3とかR2みたいなのを使う必要がある気がする MFMを描画できるようにしたい あとがき # 結構速さは重視してたりします お陰で評価は結構高いです モバイル デスクトップ 記事ページはモバイルだと微妙かも 記事ページでもデストップだといい感じ\n","date":"2024年8月20日 ","externalUrl":null,"permalink":"/posts/jisaku-cms/","section":"Posts","summary":"","title":"何を狂ったのかCMSを一から作った話","type":"posts"},{"content":"","date":"2024年8月20日 ","externalUrl":null,"permalink":"/tags/%E8%87%AA%E4%BD%9Ccms/","section":"Tags","summary":"","title":"自作CMS","type":"tags"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]